/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package com.bloogefest.common.function;

import com.bloogefest.common.validation.NullException;
import com.bloogefest.common.validation.Validator;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

/**
 * Функциональный интерфейс логического выражения.
 *
 * @since 1.0.0
 */
@FunctionalInterface
public interface Condition {

    /**
     * Инициализирует и возвращает логическое выражение, метод вычисления которого всегда возвращает переданный в этот
     * метод результат вычисления.
     *
     * @param result результат вычисления.
     *
     * @return Новое логическое выражение, метод вычисления которого всегда возвращает переданный в этот метод результат
     * вычисления.
     *
     * @since 1.0.0
     */
    @Contract(value = "_ -> new", pure = true)
    static @NotNull Condition constant(final boolean result) {
        return () -> result;
    }

    /**
     * Проверяет логическое выражение и, если то ненулевое, возвращает его, в противном случае инициализирует и бросает
     * исключение валидации нулевого объекта (логического выражения) с переопределённым сообщением (отформатированным
     * именем логического выражения шаблонным сообщением).
     *
     * @param condition логическое выражение.
     *
     * @return Логическое выражение.
     *
     * @throws NullException исключение валидации нулевого объекта (логического выражения).
     * @apiNote Этот метод можно использовать для приведения лямбда-выражений к типу логического выражения.
     * @since 1.0.0
     */
    @Contract(value = "_ -> param1", pure = true)
    static @NotNull Condition of(final @NotNull Condition condition) throws NullException {
        return Validator.notNull(condition, "condition");
    }

    /**
     * Вычисляет логическое выражение, инициализирует и возвращает результат вычисления.
     *
     * @return Результат вычисления.
     *
     * @throws ComputeException исключение вычисления функции (функции вычисления логического выражения).
     * @since 3.0.0
     */
    @Contract
    boolean compute() throws ComputeException;

    /**
     * Инициализирует логическое выражение, метод вычисления которого возвращает инвертированный результат вычисления
     * этого логического выражения.
     *
     * @return Логическое выражение с инвертированным результатом вычисления этого логического выражения.
     *
     * @since 1.0.0
     */
    @Contract(value = "-> new", pure = true)
    default @NotNull Condition invert() {
        return () -> !compute();
    }

    /**
     * Проверяет вторичное логическое выражение и, если то нулевое, инициализирует и бросает исключение валидации
     * нулевого объекта (вторичного логического выражения) с переопределённым сообщением (отформатированным именем
     * вторичного логического выражения шаблонным сообщением), в противном случае инициализирует другое логическое
     * выражение, метод вычисления которого последовательно соединяет метод вычисления этого и вторичного логического
     * выражения конъюнкцией.
     *
     * @param condition вторичное логическое выражение.
     *
     * @return Логическое выражение с соединённым конъюнкцией результатом вычисления этого и вторичного логического
     * выражения.
     *
     * @throws NullException исключение валидации нулевого объекта (вторичного логического выражения).
     * @since 1.0.0
     */
    @Contract(value = "_ -> new", pure = true)
    default @NotNull Condition and(final @NotNull Condition condition) throws NullException {
        Validator.notNull(condition, "condition");
        return () -> compute() && condition.compute();
    }

    /**
     * Проверяет вторичное логическое выражение и, если то нулевое, инициализирует и бросает исключение валидации
     * нулевого объекта (вторичного логического выражения) с переопределённым сообщением (отформатированным именем
     * вторичного логического выражения шаблонным сообщением), в противном случае инициализирует другое логическое
     * выражение, метод вычисления которого последовательно соединяет метод вычисления этого и вторичного логического
     * выражения строгой дизъюнкцией.
     *
     * @param condition вторичное логическое выражение.
     *
     * @return Логическое выражение с соединённым строгой дизъюнкцией результатом вычисления этого и вторичного
     * логического выражения.
     *
     * @throws NullException исключение валидации нулевого объекта (вторичного логического выражения).
     * @since 1.0.0
     */
    @Contract(value = "_ -> new", pure = true)
    default @NotNull Condition xor(final @NotNull Condition condition) throws NullException {
        Validator.notNull(condition, "condition");
        return () -> compute() ^ condition.compute();
    }

    /**
     * Проверяет вторичное логическое выражение и, если то нулевое, инициализирует и бросает исключение валидации
     * нулевого объекта (вторичного логического выражения) с переопределённым сообщением (отформатированным именем
     * вторичного логического выражения шаблонным сообщением), в противном случае инициализирует другое логическое
     * выражение, метод вычисления которого последовательно соединяет метод вычисления этого и вторичного логического
     * выражения мягкой дизъюнкцией.
     *
     * @param condition вторичное логическое выражение.
     *
     * @return Логическое выражение с соединённым мягкой дизъюнкцией результатом вычисления этого и вторичного
     * логического выражения.
     *
     * @throws NullException исключение валидации нулевого объекта (вторичного логического выражения).
     * @since 1.0.0
     */
    @Contract(value = "_ -> new", pure = true)
    default @NotNull Condition or(final @NotNull Condition condition) throws NullException {
        Validator.notNull(condition, "condition");
        return () -> compute() || condition.compute();
    }

    /**
     * Проверяет обратный вызов и, если тот нулевой, инициализирует и бросает исключение валидации нулевого объекта
     * (обратного вызова) с переопределённым сообщением (отформатированным именем обратного вызова шаблонным
     * сообщением), в противном случае инициализирует логическое выражение, метод вычисления которого проверяет
     * результат вычисления этого логического выражения и, если тот истинный, вызывает функцию (функцию обратного
     * вызова), а после возвращает результат вычисления этого логического выражения.
     *
     * @param callback обратный вызов.
     *
     * @return Логическое выражение с результатом вычисления этого логического выражения, при истинности которого
     * вызывается функция (функция обратного вызова).
     *
     * @throws NullException исключение валидации нулевого объекта (обратного вызова).
     * @since 4.0.0
     */
    @Contract(value = "_ -> new", pure = true)
    default @NotNull Condition then(final @NotNull Callback callback) throws NullException {
        Validator.notNull(callback, "callback");
        return () -> {
            final var result = compute();
            if (result) callback.call();
            return result;
        };
    }

    /**
     * Проверяет поставщик и, если тот нулевой, инициализирует и бросает исключение валидации нулевого объекта
     * (поставщика) с переопределённым сообщением (отформатированным именем поставщика шаблонным сообщением), в
     * противном случае инициализирует логическое выражение, метод вычисления которого проверяет результат вычисления
     * этого логического выражения и, если тот истинный, инициализирует и бросает исключение вычисления функции (объекта
     * этого предиката) с переопределённой причиной (полученным исключением либо ошибкой от поставщика), в противном
     * случае возвращает ложный результат вычисления этого логического выражения.
     *
     * @param supplier поставщик исключения либо ошибки.
     *
     * @return Логическое выражение с результатом вычисления этого логического выражения, при истинности которого
     * инициализируется и бросается исключение вычисления функции (объекта этого предиката) с переопределённой причиной
     * (полученным исключением либо ошибкой от поставщика).
     *
     * @throws NullException исключение валидации нулевого объекта (поставщика).
     * @since 4.0.0
     */
    @Contract(value = "_ -> new", pure = true)
    default @NotNull Condition then(final @NotNull Supplier<? extends Throwable> supplier) throws NullException {
        Validator.notNull(supplier, "supplier");
        return () -> {
            if (compute()) throw new ComputeException(supplier.supply());
            return false;
        };
    }

    /**
     * Проверяет обратный вызов и, если тот нулевой, инициализирует и бросает исключение валидации нулевого объекта
     * (обратного вызова) с переопределённым сообщением (отформатированным именем обратного вызова шаблонным
     * сообщением), в противном случае инициализирует логическое выражение, метод вычисления которого проверяет
     * результат вычисления этого логического выражения и, если тот ложный, вызывает функцию (функцию обратного вызова),
     * а после возвращает результат вычисления этого логического выражения.
     *
     * @param callback обратный вызов.
     *
     * @return Логическое выражение с результатом вычисления этого логического выражения, при ложности которого
     * вызывается функция (функция обратного вызова).
     *
     * @throws NullException исключение валидации нулевого объекта (обратного вызова).
     * @since 4.0.0
     */
    @Contract(value = "_ -> new", pure = true)
    default @NotNull Condition otherwise(final @NotNull Callback callback) throws NullException {
        Validator.notNull(callback, "callback");
        return () -> {
            final var result = compute();
            if (!result) callback.call();
            return result;
        };
    }

    /**
     * Проверяет поставщик и, если тот нулевой, инициализирует и бросает исключение валидации нулевого объекта
     * (поставщика) с переопределённым сообщением (отформатированным именем поставщика шаблонным сообщением), в
     * противном случае инициализирует логическое выражение, метод вычисления которого проверяет результат вычисления
     * этого логического выражения и, если тот ложный, инициализирует и бросает исключение вычисления функции (объекта
     * этого предиката) с переопределённой причиной (полученным исключением либо ошибкой от поставщика), в противном
     * случае возвращает истинный результат вычисления этого логического выражения.
     *
     * @param supplier поставщик исключения либо ошибки.
     *
     * @return Логическое выражение с результатом вычисления этого логического выражения, при ложности которого
     * инициализируется и бросается исключение вычисления функции (объекта этого предиката) с переопределённой причиной
     * (полученным исключением либо ошибкой от поставщика).
     *
     * @throws NullException исключение валидации нулевого объекта (поставщика).
     * @since 4.0.0
     */
    @Contract(value = "_ -> new", pure = true)
    default @NotNull Condition otherwise(final @NotNull Supplier<? extends Throwable> supplier) throws NullException {
        Validator.notNull(supplier, "supplier");
        return () -> {
            if (!compute()) throw new ComputeException(supplier.supply());
            return true;
        };
    }

}
