/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package com.bloogefest.common.function;

import com.bloogefest.annotation.Contract;
import com.bloogefest.annotation.NonNull;
import com.bloogefest.annotation.Nullable;
import com.bloogefest.common.validation.NullException;
import com.bloogefest.common.validation.Validator;

/**
 * Функция алгебры логики — это функциональный интерфейс. Позволяет описать функцию без экземпляров-параметров, но с
 * логическим экземпляром-результатом.
 *
 * @since 1.0.0
 */
@FunctionalInterface
public interface Condition {

    /**
     * Создаёт и возвращает (1).
     *
     * @param result экземпляр-результат.
     *
     * @return (1).
     *
     * @apiNote (1) — это функция алгебры логики с переданным в этот метод экземпляром-результатом.
     * @since 1.0.0
     */
    @Contract(value = "? -> new", impact = Contract.Impact.NONE)
    static @NonNull Condition constant(final boolean result) {
        return () -> result;
    }

    /**
     * Возвращает (1).
     *
     * @param condition функция алгебры логики.
     *
     * @return (1).
     *
     * @apiNote (1) — это переданная в этот метод функция алгебры логики.
     * @since 4.0.0-RC3
     */
    @Contract(value = "? -> 1", impact = Contract.Impact.NONE)
    static @Nullable Condition lambda(final @Nullable Condition condition) {
        return condition;
    }

    /**
     * Выполняет (1).
     *
     * @return Экземпляр-результат (1).
     *
     * @throws ConditionException исключение выполнения (1).
     * @throws ConditionError ошибка выполнения (1).
     * @apiNote (1) — это описанная функция без экземпляров-параметров, но с логическим экземпляром-результатом.
     * @since 3.0.0
     */
    @Contract(value = "-> ?", impact = Contract.Impact.UNDEFINED)
    boolean compute() throws ConditionException, ConditionError;

    /**
     * Инициализирует и возвращает логическую функцию, метод вычисления которой сначала вызывает метод вычисления этой
     * логической функции, а после инвертирует и возвращает её результат вычисления.
     *
     * @return Новая логическая функция, метод вычисления которой сначала вызывает метод вычисления этой логической
     * функции, а после инвертирует и возвращает её результат вычисления.
     *
     * @since 1.0.0
     */
    @Contract(value = "-> new")
    default @NonNull Condition invert() {
        return () -> !compute();
    }

    /**
     * Проверяет переданную логическую функцию и, если та нулевая, генерирует исключение валидации нулевого объекта
     * (переданной логической функции) с переопределённым сообщением (отформатированным именем переданной логической
     * функции шаблонным сообщением), в противном случае инициализирует другую логическую функцию, метод вычисления
     * которой вызывает метод вычисления этой логической функции и, если её результат вычисления истинный, вызывает
     * метод вычисления переданной в этот метод логической функции, а после возвращает её результат вычисления, в
     * противном случае возвращает ложный результат вычисления.
     *
     * @param condition логическая функция.
     *
     * @return Новая логическая функция, метод вычисления которой вызывает метод вычисления этой логической функции и,
     * если её результат вычисления истинный, вызывает метод вычисления переданной в этот метод логической функции, а
     * после возвращает её результат вычисления, в противном случае возвращает ложный результат вычисления.
     *
     * @throws NullException исключение валидации нулевого объекта (переданной логической функции).
     * @since 1.0.0
     */
    @Contract(value = "_ -> new")
    default @NonNull Condition and(final @NonNull Condition condition) throws NullException {
        Validator.notNull(condition, "condition");
        return () -> compute() && condition.compute();
    }

    /**
     * Проверяет переданную логическую функцию и, если та нулевая, генерирует исключение валидации нулевого объекта
     * (переданной логической функции) с переопределённым сообщением (отформатированным именем переданной логической
     * функции шаблонным сообщением), в противном случае инициализирует другую логическую функцию, метод вычисления
     * которой сначала вызывает метод вычисления этой логической функции, потом вызывает метод вычисления переданной в
     * этот метод логической функции и, если их результаты вычисления неравны, возвращает истинный результат вычисления,
     * в противном случае возвращает ложный результат вычисления.
     *
     * @param condition логическая функция.
     *
     * @return Новая логическая функция, метод вычисления которой сначала вызывает метод вычисления этой логической
     * функции, потом вызывает метод вычисления переданной в этот метод логической функции и, если их результаты
     * вычисления неравны, возвращает истинный результат вычисления, в противном случае возвращает ложный результат
     * вычисления.
     *
     * @throws NullException исключение валидации нулевого объекта (переданной логической функции).
     * @since 1.0.0
     */
    @Contract(value = "_ -> new")
    default @NonNull Condition xor(final @NonNull Condition condition) throws NullException {
        Validator.notNull(condition, "condition");
        return () -> compute() ^ condition.compute();
    }

    /**
     * Проверяет переданную логическую функцию и, если та нулевая, генерирует исключение валидации нулевого объекта
     * (переданной логической функции) с переопределённым сообщением (отформатированным именем переданной логической
     * функции шаблонным сообщением), в противном случае инициализирует другую логическую функцию, метод вычисления
     * которой вызывает метод вычисления этой логической функции и, если её результат вычисления истинный, возвращает
     * истинный результат вычисления, в противном случае вызывает метод вычисления переданной в этот метод логической
     * функции, а после возвращает её результат вычисления.
     *
     * @param condition логическая функция.
     *
     * @return Новая логическая функция, метод вычисления которой вызывает метод вычисления этой логической функции и,
     * если её результат вычисления истинный, возвращает истинный результат вычисления, в противном случае вызывает
     * метод вычисления переданной в этот метод логической функции, а после возвращает её результат вычисления.
     *
     * @throws NullException исключение валидации нулевого объекта (переданной логической функции).
     * @since 1.0.0
     */
    @Contract(value = "_ -> new")
    default @NonNull Condition or(final @NonNull Condition condition) throws NullException {
        Validator.notNull(condition, "condition");
        return () -> compute() || condition.compute();
    }

    /**
     * Проверяет переданную функцию обратного вызова и, если та нулевая, генерирует исключение валидации нулевого
     * объекта (переданной функции обратного вызова) с переопределённым сообщением (отформатированным именем переданной
     * функции обратного вызова шаблонным сообщением), в противном случае инициализирует и возвращает логическую
     * функцию, метод вычисления которой вызывает метод вычисления этой логической функции и, если результат её
     * вычисления истинный, вызывает функцию обратного вызова, а после либо в противном случае возвращает результат
     * вычисления этой логической функции.
     *
     * @param callback функция обратного вызова.
     *
     * @return Новая логическая функция, метод вычисления которой вызывает метод вычисления этой логической функции и,
     * если результат её вычисления истинный, вызывает функцию обратного вызова, а после либо в противном случае
     * возвращает результат вычисления этой логической функции.
     *
     * @throws NullException исключение валидации нулевого объекта (переданной функции обратного вызова).
     * @since 4.0.0-RC1
     */
    @Contract(value = "_ -> new")
    default @NonNull Condition then(final @NonNull Callback callback) throws NullException {
        Validator.notNull(callback, "callback");
        return () -> {
            final var result = compute();
            if (result) callback.call();
            return result;
        };
    }

    /**
     * Проверяет переданный поставщик и, если тот нулевой, генерирует исключение валидации нулевого объекта (переданного
     * поставщика) с переопределённым сообщением (отформатированным именем переданного поставщика шаблонным сообщением),
     * в противном случае инициализирует и возвращает логическую функцию, метод вычисления которой вызывает метод
     * вычисления этой логической функции и, если результат её вычисления истинный, генерирует исключение вычисления
     * функции (этой логической функции) с переопределённой причиной (полученным исключением либо ошибкой от переданного
     * в этот метод поставщика), в противном случае возвращает ложный результат вычисления.
     *
     * @param supplier поставщик исключения либо ошибки.
     *
     * @return Новая логическая функция, метод вычисления которой вызывает метод вычисления этой логической функции и,
     * если результат её вычисления истинный, генерирует исключение вычисления функции (этой логической функции) с
     * переопределённой причиной (полученным исключением либо ошибкой от переданного в этот метод поставщика), в
     * противном случае возвращает ложный результат вычисления.
     *
     * @throws NullException исключение валидации нулевого объекта (переданного поставщика).
     * @since 4.0.0-RC1
     */
    @Contract(value = "_ -> new")
    default @NonNull Condition then(final @NonNull Supplier<? extends Throwable> supplier) throws NullException {
        Validator.notNull(supplier, "supplier");
        return () -> {
            if (compute()) throw new ComputeException(supplier.get());
            return false;
        };
    }

    /**
     * Проверяет переданную функцию обратного вызова и, если та нулевая, генерирует исключение валидации нулевого
     * объекта (переданной функции обратного вызова) с переопределённым сообщением (отформатированным именем переданной
     * функции обратного вызова шаблонным сообщением), в противном случае инициализирует и возвращает логическую
     * функцию, метод вычисления которой вызывает метод вычисления этой логической функции и, если результат её
     * вычисления ложный, вызывает функцию обратного вызова, а после либо в противном случае возвращает результат
     * вычисления этой логической функции.
     *
     * @param callback функция обратного вызова.
     *
     * @return Новая логическая функция, метод вычисления которой вызывает метод вычисления этой логической функции и,
     * если результат её вычисления ложный, вызывает функцию обратного вызова, а после либо в противном случае
     * возвращает результат вычисления этой логической функции.
     *
     * @throws NullException исключение валидации нулевого объекта (переданной функции обратного вызова).
     * @since 4.0.0-RC1
     */
    @Contract(value = "_ -> new")
    default @NonNull Condition otherwise(final @NonNull Callback callback) throws NullException {
        Validator.notNull(callback, "callback");
        return () -> {
            final var result = compute();
            if (!result) callback.call();
            return result;
        };
    }

    /**
     * Проверяет переданный поставщик и, если тот нулевой, генерирует исключение валидации нулевого объекта (переданного
     * поставщика) с переопределённым сообщением (отформатированным именем переданного поставщика шаблонным сообщением),
     * в противном случае инициализирует и возвращает логическую функцию, метод вычисления которой вызывает метод
     * вычисления этой логической функции и, если результат её вычисления ложный, генерирует исключение вычисления
     * функции (этой логической функции) с переопределённой причиной (полученным исключением либо ошибкой от переданного
     * в этот метод поставщика), в противном случае возвращает истинный результат вычисления.
     *
     * @param supplier поставщик исключения либо ошибки.
     *
     * @return Новая логическая функция, метод вычисления которой вызывает метод вычисления этой логической функции и,
     * если результат её вычисления ложный, генерирует исключение вычисления функции (этой логической функции) с
     * переопределённой причиной (полученным исключением либо ошибкой от переданного в этот метод поставщика), в
     * противном случае возвращает истинный результат вычисления.
     *
     * @throws NullException исключение валидации нулевого объекта (переданного поставщика).
     * @since 4.0.0-RC1
     */
    @Contract(value = "_ -> new")
    default @NonNull Condition otherwise(final @NonNull Supplier<? extends Throwable> supplier) throws NullException {
        Validator.notNull(supplier, "supplier");
        return () -> {
            if (!compute()) throw new ComputeException(supplier.get());
            return true;
        };
    }

}
