/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package com.bloogefest.common.function;

import com.bloogefest.common.validation.NullException;
import com.bloogefest.common.validation.Validator;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

/**
 * Функциональный интерфейс логической функции.
 *
 * @since 1.0.0
 */
@FunctionalInterface
public interface Condition {

    /**
     * Инициализирует и возвращает логическую функцию, метод вычисления которой всегда возвращает переданный в этот
     * метод результат вычисления.
     *
     * @param result результат вычисления.
     *
     * @return Новая логическая функция, метод вычисления которой всегда возвращает переданный в этот метод результат
     * вычисления.
     *
     * @since 1.0.0
     */
    @Contract(value = "_ -> new", pure = true)
    static @NotNull Condition constant(final boolean result) {
        return () -> result;
    }

    /**
     * Проверяет переданную логическую функцию и, если та ненулевая, возвращает её, в противном случае инициализирует и
     * бросает исключение валидации нулевого объекта (переданной логической функции) с переопределённым сообщением
     * (отформатированным именем переданной логической функции шаблонным сообщением).
     *
     * @param condition логическая функция.
     *
     * @return Переданная логическая функция.
     *
     * @throws NullException исключение валидации нулевого объекта (переданной логической функции).
     * @apiNote Этот метод можно использовать для приведения лямбда-выражений к типу логической функции.
     * @since 1.0.0
     */
    @Contract(value = "_ -> param1", pure = true)
    static @NotNull Condition of(final @NotNull Condition condition) throws NullException {
        return Validator.notNull(condition, "condition");
    }

    /**
     * Вычисляет эту логическую функцию, инициализирует и возвращает результат её вычисления.
     *
     * @return Результат вычисления этой логической функции.
     *
     * @throws ComputeException исключение вычисления функции (этой логической функции).
     * @since 3.0.0
     */
    @Contract
    boolean compute() throws ComputeException;

    /**
     * Инициализирует и возвращает логическую функцию, метод вычисления которой вызывает метод вычисления этой
     * логической функции, а после инвертирует и возвращает результат её вычисления.
     *
     * @return Новое логическое выражение, метод вычисления которой вызывает метод вычисления этой логической функции, а
     * после инвертирует и возвращает результат её вычисления.
     *
     * @since 1.0.0
     */
    @Contract(value = "-> new", pure = true)
    default @NotNull Condition invert() {
        return () -> !compute();
    }

    /**
     * Проверяет переданную логическую функцию и, если та нулевая, инициализирует и бросает исключение валидации
     * нулевого объекта (переданной логической функции) с переопределённым сообщением (отформатированным именем
     * переданной логической функции шаблонным сообщением), в противном случае инициализирует другую логическую функцию,
     * метод вычисления которой вызывает метод вычисления этой логической функции и, если результат её вычисления
     * истинный, вызывает метод вычисления переданной в этот метод логической функции, а после возвращает результат её
     * вычисления, в противном случае возвращает ложный результат вычисления.
     *
     * @param condition логическая функция.
     *
     * @return Новая логическая функция, метод вычисления которой вызывает метод вычисления этой логической функции и,
     * если результат её вычисления истинный, вызывает метод вычисления переданной в этот метод логической функции, а
     * после возвращает результат её вычисления, в противном случае возвращает ложный результат вычисления.
     *
     * @throws NullException исключение валидации нулевого объекта (переданной логической функции).
     * @since 1.0.0
     */
    @Contract(value = "_ -> new", pure = true)
    default @NotNull Condition and(final @NotNull Condition condition) throws NullException {
        Validator.notNull(condition, "condition");
        return () -> compute() && condition.compute();
    }

    /**
     * Проверяет логическое выражение и, если то нулевое, инициализирует и бросает исключение валидации нулевого объекта
     * (логического выражения) с переопределённым сообщением (отформатированным именем логического выражения шаблонным
     * сообщением), в противном случае инициализирует другое логическое выражение, метод вычисления которого сначала
     * вызывает метод вычисления этого логического выражения, потом вызывает метод вычисления переданного в этот метод
     * логического выражения и, если результаты их вычисления неравны, возвращает истинный результат вычисления, в
     * противном случае возвращает ложный результат вычисления.
     *
     * @param condition логическое выражение.
     *
     * @return Новое логическое выражение, метод вычисления которого сначала вызывает метод вычисления этого логического
     * выражения, потом вызывает метод вычисления переданного в этот метод логического выражения и, если результаты их
     * вычисления неравны, возвращает истинный результат вычисления, в противном случае возвращает ложный результат
     * вычисления.
     *
     * @throws NullException исключение валидации нулевого объекта (логического выражения).
     * @since 1.0.0
     */
    @Contract(value = "_ -> new", pure = true)
    default @NotNull Condition xor(final @NotNull Condition condition) throws NullException {
        Validator.notNull(condition, "condition");
        return () -> compute() ^ condition.compute();
    }

    /**
     * Проверяет логическое выражение и, если то нулевое, инициализирует и бросает исключение валидации нулевого объекта
     * (логического выражения) с переопределённым сообщением (отформатированным именем логического выражения шаблонным
     * сообщением), в противном случае инициализирует другое логическое выражение, метод вычисления которого вызывает
     * метод вычисления этого логического выражения и, если результат его вычисления истинный, возвращает истинный
     * результат вычисления, в противном случае вызывает метод вычисления переданного в этот метод логического
     * выражения, а после возвращает результат его вычисления.
     *
     * @param condition логическое выражение.
     *
     * @return Новое логическое выражение, метод вычисления которого вызывает метод вычисления этого логического
     * выражения и, если результат его вычисления истинный, возвращает истинный результат вычисления, в противном случае
     * вызывает метод вычисления переданного в этот метод логического выражения, а после возвращает результат его
     * вычисления.
     *
     * @throws NullException исключение валидации нулевого объекта (логического выражения).
     * @since 1.0.0
     */
    @Contract(value = "_ -> new", pure = true)
    default @NotNull Condition or(final @NotNull Condition condition) throws NullException {
        Validator.notNull(condition, "condition");
        return () -> compute() || condition.compute();
    }

    /**
     * Проверяет обратный вызов и, если тот нулевой, инициализирует и бросает исключение валидации нулевого объекта
     * (функции обратного вызова) с переопределённым сообщением (отформатированным именем функции обратного вызова
     * шаблонным сообщением), в противном случае инициализирует и возвращает логическое выражение, метод вычисления
     * которого вызывает метод вычисления этого логического выражения и, если результат его вычисления истинный,
     * вызывает функцию обратного вызова, а после либо в противном случае возвращает результат вычисления этого
     * логического выражения.
     *
     * @param callback функция обратный вызов.
     *
     * @return Новое логическое выражение, метод вычисления которого вызывает метод вычисления этого логического
     * выражения и, если результат его вычисления истинный, вызывает функцию обратного вызова, а после либо в противном
     * случае возвращает результат вычисления этого логического выражения.
     *
     * @throws NullException исключение валидации нулевого объекта (функции обратного вызова).
     * @since 4.0.0
     */
    @Contract(value = "_ -> new", pure = true)
    default @NotNull Condition then(final @NotNull Callback callback) throws NullException {
        Validator.notNull(callback, "callback");
        return () -> {
            final var result = compute();
            if (result) callback.call();
            return result;
        };
    }

    /**
     * Проверяет поставщик и, если тот нулевой, инициализирует и бросает исключение валидации нулевого объекта
     * (поставщика) с переопределённым сообщением (отформатированным именем поставщика шаблонным сообщением), в
     * противном случае инициализирует и возвращает логическую функцию, метод вычисления которого вызывает метод
     * вычисления этой логической функции и, если её результат вычисления истинный, инициализирует и бросает исключение
     * вычисления функции (этой логической функции) с переопределённой причиной (полученным исключением либо ошибкой от
     * поставщика), в противном случае возвращает ложный результат вычисления.
     *
     * @param supplier поставщик исключения либо ошибки.
     *
     * @return Новая логическая функция, метод вычисления которого вызывает метод вычисления этой логической функции и,
     * если её результат вычисления истинный, инициализирует и бросает исключение вычисления функции (этой логической
     * функции) с переопределённой причиной (полученным исключением либо ошибкой от поставщика), в противном случае
     * возвращает ложный результат вычисления.
     *
     * @throws NullException исключение валидации нулевого объекта (поставщика).
     * @since 4.0.0
     */
    @Contract(value = "_ -> new", pure = true)
    default @NotNull Condition then(final @NotNull Supplier<? extends Throwable> supplier) throws NullException {
        Validator.notNull(supplier, "supplier");
        return () -> {
            if (compute()) throw new ComputeException(supplier.supply());
            return false;
        };
    }

    /**
     * Проверяет обратный вызов и, если тот нулевой, инициализирует и бросает исключение валидации нулевого объекта
     * (обратного вызова) с переопределённым сообщением (отформатированным именем обратного вызова шаблонным
     * сообщением), в противном случае инициализирует логическое выражение, метод вычисления которого проверяет
     * результат вычисления этого логического выражения и, если тот ложный, вызывает функцию (функцию обратного вызова),
     * а после возвращает результат вычисления этого логического выражения.
     *
     * @param callback обратный вызов.
     *
     * @return Логическое выражение с результатом вычисления этого логического выражения, при ложности которого
     * вызывается функция (функция обратного вызова).
     *
     * @throws NullException исключение валидации нулевого объекта (обратного вызова).
     * @since 4.0.0
     */
    @Contract(value = "_ -> new", pure = true)
    default @NotNull Condition otherwise(final @NotNull Callback callback) throws NullException {
        Validator.notNull(callback, "callback");
        return () -> {
            final var result = compute();
            if (!result) callback.call();
            return result;
        };
    }

    /**
     * Проверяет поставщик и, если тот нулевой, инициализирует и бросает исключение валидации нулевого объекта
     * (поставщика) с переопределённым сообщением (отформатированным именем поставщика шаблонным сообщением), в
     * противном случае инициализирует логическое выражение, метод вычисления которого проверяет результат вычисления
     * этого логического выражения и, если тот ложный, инициализирует и бросает исключение вычисления функции (объекта
     * этого предиката) с переопределённой причиной (полученным исключением либо ошибкой от поставщика), в противном
     * случае возвращает истинный результат вычисления этого логического выражения.
     *
     * @param supplier поставщик исключения либо ошибки.
     *
     * @return Логическое выражение с результатом вычисления этого логического выражения, при ложности которого
     * инициализируется и бросается исключение вычисления функции (объекта этого предиката) с переопределённой причиной
     * (полученным исключением либо ошибкой от поставщика).
     *
     * @throws NullException исключение валидации нулевого объекта (поставщика).
     * @since 4.0.0
     */
    @Contract(value = "_ -> new", pure = true)
    default @NotNull Condition otherwise(final @NotNull Supplier<? extends Throwable> supplier) throws NullException {
        Validator.notNull(supplier, "supplier");
        return () -> {
            if (!compute()) throw new ComputeException(supplier.supply());
            return true;
        };
    }

}
